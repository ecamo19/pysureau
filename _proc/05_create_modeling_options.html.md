---
description: 'AUTHORS: __Julien Ruffault (julien.ruff@gmail.com), Nicolas Martin-StPaul
  (nicolas.martin@inrae.fr)__'
output-file: create_modeling_options.html
title: Create modeling options

---


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

::: {#cell-2 .cell}
``` {.python .cell-code}
#def create_modeling_options(
#   latitude:float, # Numerical value indicating the latitude of the stand
#   longitude:float, # Numerical value indicating the longitude of the stand
#   year_start:int, # Numeric indicating the start year for the simulation (must match the dates of the input climate data file)
#   year_end:int,   # Numeric indicating the end year for the simulation (must match the dates of the input climate data file)
#   output_path:str = "./sureau_outputs",  # Path to folder where a CSV output result file will be saved. By default `None` which means that no file is written
#   time_step_for_evapo: int = 1,  # Numerical value (in hours) indicating the time step for the main evapotranspiration loop. Should be one of the following 1,2,4,6,8
#   resolution_output: str = 'subdaily',  # the resolution chosen to write variables in files, `subdaily`, `daily` or `yearly`.
#   output_type: str = "simple",  # The output variables of the model that should be written in the output model file.
#   output_overwrite: bool = False,  # Boolean indicating whether the output result file can be overwritten if it already exists
#   defoliation: bool = False,  # Boolean indicating whether trees should loose leaves when`occurs.cavitation` occurs of the above part of plant. Defoliation starts only when PLC_Leaf > 10% .
#   threshold_mortality: int = 90,  # Percentange value indicating the percentage loss of conductivity above which the plant is considered dead and simulation stops for the current year.
#   transpiration_model: str = 'jarvis',  # Transpiration model type. Either  or 'granier' 
#   transpiration_granier_arg_a:float = -0.006, # Unknown parameter definition
#   transpiration_granier_arg_b:float = 0.134, # Unknown parameter definition
#   transpiration_granier_arg_c:float = 0, # Unknown parameter definition
#   pet_formulation: str = 'pt',  # Formulation of ETP to be used, either `pt` (Priestley-Taylor) or `penman` (Penmman)
#   rn_formulation: str = 'linacre',  # Method to be used to calculate net radiation from global radiation, either `linacre`  or 'linear' (the linear method is not implemnted yet)
#   constant_climate: bool = False,  # Boolian indicating whether the climate should be considered constant or not
#   comp_options_for_evapo: str = 'normal',  # Option to be used for the loops (voir avec Francois). Choose between 'normal', 'accurate','fast' or 'custom'
#   custom_small_time_step_in_sec: int = 600,  # Time step in seconds. Use if comp_options_for_evapo is set to `custom`
#   lcav: int = 1,  # Boolean (0/1) to offset cavitation release from the apoplasm of leaves
#   scav: int = 1,  # Boolean (0/1) to offset cavitation release from the apoplasm of stem
#   eord: int = 1,  # Unknown parameter definition
#   numerical_scheme: str = 'implicit',   # Method to be used, either "implicit", "semi-implicit" (Xu) or 'explicit' 
#   stomatal_reg_formulation: str = 'sigmoid',  # Type of regulation to be used for stomatal response to leaf symplasmic water potential, either `sigmoid`, `piecewise_linear` or 'turgor'
#   print_prog: bool = True,  # Print progress of simulation to console (T/F)?
# -> Dict:
#   'Create a dictionary containing modeling options that can be used as an input in run.SurEauR'#
#   # Validate the function parameter types -------------------------------------
#   
#   # Make sure output_path str
#   assert isinstance(
#       output_path, str
#   ), f'output_path must be a string not a {type(output_path)}'#
#   if not os.path.isdir(output_path):
#       raise ValueError(
#           f'Directory {output_path}, does not exist, check presence or spelling'
#       )
#   
#   assert isinstance(
#       output_path, str
#   ), f'output_path must be a string not a {type(output_path)}'
#   
#   # Latitude
#   assert (
#       isinstance(latitude, float) | isinstance(latitude, int)
#       and 95 >= latitude >= -95
#   ), 'Provide latitude as coordinates points bewteen -90 and 90 i.e. latitude = 41.40338'
#   
#   # Longitude
#   assert (
#       isinstance(longitude, float) | isinstance(longitude, int)
#       and 180 >= longitude >= -180
#   ), 'Provide longitude as coordinates points bewteen -180 and 180 i.e. longitude = 179.001'
#   
#   # year_start
#   assert (
#       isinstance(year_start, int) and 3000 >= year_start > 0
#   ), 'year_start must be a integer value between 0-3000'
#   
#   # year_end
#   assert (
#       isinstance(year_end, int) and 3000 >= year_end > 0
#   ), 'year_end must be a integer value between 0-3000'
#   
#   # Compare end_year_simulation is larger than start_year_simulation
#   assert (
#       year_start <= year_end
#   ), f'year_start ({year_start}) is larger than year_end ({year_end})'
#   
#   # Time step
#   assert time_step_for_evapo in [
#       "variable",
#       1,
#       2,
#       4,
#       6,
#   ], 'time_step_for_evap must be set as 1, 2, 4, 6 or "variable"'
#   
#   # Make sure that resolution output only has three options
#   assert (
#       resolution_output
#       in [
#           'subdaily',
#           'daily',
#           'yearly',
#       ]
#   ), f'{resolution_output} not a valid option for resolution_output, select "subdaily", "daily" or "yearly"'
#   
#   # Make sure that output_type only has four options
#   assert (
#       output_type
#       in [
#           "simple", 
#           "diagnostic", 
#           "LFMC", 
#           "forest_diback",
#       ]
#   ), f'{output_type} not a valid option for output_type, select "simple", "diagnostic", "LFMC" or "forest_diback"'#
#   # output_overwrite
#   assert isinstance(output_overwrite, bool), 'output_overwrite must be a boolean (True/False)'
#   
#   assert isinstance(
#       constant_climate, bool
#   ), 'constant_climate must be a boolean (True/False)'#
#   assert isinstance(
#       defoliation, bool
#   ), 'defoliation must be a boolean (True/False)'#
#   assert (
#       isinstance(threshold_mortality, int) and 50 <= threshold_mortality <= 100
#   ), 'threshold_mortality must be a integer between 50 and 100'#
#   assert pet_formulation in [
#       'pt',
#       'penman',
#   ], f'{pet_formulation} not a valid option for pet_formulation, choose "pt" or "penman"'#
#   assert rn_formulation in [
#       'linacre',
#       'linear',
#   ], f'{rn_formulation} not a valid option for, choose "linacre" or "linear"'#
#   assert (
#       comp_options_for_evapo
#       in [
#           'normal',
#           'accurate',
#           'fast',
#           'custom',
#       ]
#   ), f'{comp_options_for_evapo} not a valid option for comp_options_for_evapo, choose "normal", "accurate", "fast" or "custom" '#
#   assert (
#       stomatal_reg_formulation
#       in [
#           'sigmoid',
#           'piecewise_linear',
#           'turgor',
#       ]
#   ), f'{stomatal_reg_formulation} not a valid option for stomatal_reg_formulation, choose "sigmoid", "piecewise_linear" or "turgor" '#
#   assert transpiration_model in [
#       'jarvis',
#       'granier',
#   ], f'{transpiration_model} not a valid option for transpiration_model, choose  "jarvis" or "granier"'#
#   assert (
#       numerical_scheme
#       in [
#           'implicit',
#           'semi-implicit',
#           'explicit',
#       ]
#   ), f'{numerical_scheme} not a valid option for numerical_scheme, choose  "implicit", "semi-implicit" or "explicit"'#
#   # Create array with time steps for the evapo --------------------------------
#   if time_step_for_evapo == "variable":
#       time = np.array([0, 6, 12, 14, 16, 22])
#       raise ValueError('time_step_for_evapo set to "variable". This has not been implemented yet')#
#   elif time_step_for_evapo != "variable":
#       time = np.arange(0, 24, time_step_for_evapo, dtype=int)#
#   # Create comp_options -------------------------------------------------------
#   comp_options = collections.defaultdict(list)
#   
#   # Every 10min, 6min, 3min, 1min
#   if comp_options_for_evapo == 'normal':
#           # Add key value pairs to the comp_dictionary
#           comp_options['numerical_scheme'] = numerical_scheme
#           comp_options['nsmalltimesteps'] = time_step_for_evapo * np.array(
#               [6, 10, 20, 60]
#           )
#           comp_options['lsym'] = 1
#           comp_options['ssym'] = 1
#           comp_options['clapo'] = 1
#           comp_options['ctapo'] = 1
#           comp_options['eord'] = eord
#           comp_options['lcav'] = lcav
#           comp_options['scav'] = scav#
#   # every 10 seconds
#   if comp_options_for_evapo == 'accurate':
#           comp_options['numerical_scheme'] = numerical_scheme
#           comp_options['nsmalltimesteps'] = time_step_for_evapo * np.array([600])
#           comp_options['lsym'] = 1
#           comp_options['ssym'] = 1
#           comp_options['clapo'] = 1
#           comp_options['ctapo'] = 1
#           comp_options['eord'] = eord
#           comp_options['lcav'] = lcav
#           comp_options['scav'] = scav#
#   # every hours, every 10 min
#   if comp_options_for_evapo == 'fast':
#           comp_options['numerical_scheme'] = numerical_scheme
#           comp_options['nsmalltimesteps'] = time_step_for_evapo * np.array([
#               1, 6]
#           )
#           comp_options['lsym'] = 1
#           comp_options['ssym'] = 1
#           comp_options['clapo'] = 1
#           comp_options['ctapo'] = 1
#           comp_options['eord'] = eord
#           comp_options['lcav'] = lcav
#           comp_options['scav'] = scav#
#   # every customSmallTimeStepInSec        
#   if comp_options_for_evapo == 'custom':  
#       
#           comp_options['numerical_scheme'] = numerical_scheme#
#           comp_options['nsmalltimesteps'] = (
#               (time_step_for_evapo * 3600) / custom_small_time_step_in_sec
#           )
#           comp_options['lsym'] = 1
#           comp_options['ssym'] = 1
#           comp_options['clapo'] = 1
#           comp_options['ctapo'] = 1
#           comp_options['eord'] = eord
#           comp_options['lcav'] = lcav
#           comp_options['scav'] = scav#
#   # Create empty dictionary for storing modeling options ----------------------    
#   modeling_options = collections.defaultdict(list)
#    
#   # Append parameters to dictionary
#   modeling_options['year_start'] = year_start
#   modeling_options['year_end'] = year_end 
#   modeling_options['resolution_output'] = resolution_output
#   modeling_options['output_type'] = output_type
#   modeling_options['constant_climate'] = constant_climate
#   modeling_options['pet_formulation'] = pet_formulation
#   modeling_options['rn_formulation'] = rn_formulation
#   modeling_options['time_step_for_evapo'] = time_step_for_evapo
#   modeling_options['time'] = time
#   modeling_options['latitude'] = latitude
#   modeling_options['longitude'] = longitude
#   modeling_options['comp_options'] = comp_options
#   modeling_options['stomatal_reg_formulation'] = stomatal_reg_formulation
#   modeling_options['defoliation'] = defoliation
#   modeling_options['threshold_mortality'] = threshold_mortality
#   modeling_options['transpiration_model'] = transpiration_model
#   modeling_options['print_prog'] = print_prog
#   modeling_options['stop_simulation_dead_plant'] = print_prog
#   modeling_options['transpiration_granier_args'] = collections.defaultdict(list,{"a":transpiration_granier_arg_a, 
#                                                                                  "b":transpiration_granier_arg_b,
#                                                                                  "c":transpiration_granier_arg_c})
#   # Create folder for storing output ------------------------------------------
#   # Create random number for naming folder
#   random_number = random.randint(1, 10000)
#   
#   # Join path for storing output
#   
#   output_path = os.path.join(output_path, f'sureau_output_{datetime.datetime.now().strftime("%Y_%m_%d")}_{random_number}')
#   modeling_options['output_path'] = output_path #
#   # New folder
#   if not os.path.exists(output_path):
#       # Create folder
#       os.mkdir(output_path)
#       print(f'Directory for storing output created at {output_path}')#
#   # Overwrite folder
#   elif os.path.exists(output_path) and output_overwrite is True:
#       shutil.rmtree(output_path)
#       os.makedirs(output_path)
#       modeling_options['output_path'] = output_path
#       print(f'Directory ({output_path}) for storing output overwritten')#
#   # Errors
#   elif os.path.exists(output_path) and output_overwrite is False:
#       raise ValueError(
#           "File already exists and 'output_overwrite' option is set to False, change the 'output_path' or set 'overwrite' to True"
#       )#
#   else:
#       raise ValueError(
#           'Error creating folder in modeling_options function'
#       )
#       
#   return modeling_options
```
:::


---

[source](https://github.com/ecamo19/pysureau/blob/master/pysureau/create_modeling_options.py#L17){target="_blank" style="float:right; font-size:smaller"}

### create_empty_modeling_options_file

>      create_empty_modeling_options_file (path:pathlib._local.Path)

*Function for creating the CSV templates necessary for the modeling options file*

|    | **Type** | **Details** |
| -- | -------- | ----------- |
| path | Path | Path to the folder where the parameter files will be saved. If set to None then the files will be saved at the current working directory |
| **Returns** | **Dict** | **Return two dictionary file for user input** |


#### __Example: Create modeling options dictionary__

::: {#cell-5 .cell}
``` {.python .cell-code}
#create_modeling_options(
#    output_path = "/tmp",
#    resolution_output= "daily",
#    output_type= "simple",
#    output_overwrite=True,   
#    latitude = 90,
#    longitude= 180,
#    lcav=1,
#    scav=1,
#    eord=1,
#    print_prog=True,
#    year_start = 1991,
#    year_end = 1992,
#    custom_small_time_step_in_sec=600,
#    time_step_for_evapo= 1,
#    constant_climate=True,
#    defoliation=True,
#    threshold_mortality=51,
#    pet_formulation='pt',
#    rn_formulation='linear',
#    comp_options_for_evapo='normal',
#    stomatal_reg_formulation='turgor',
#    transpiration_model='jarvis',
#    numerical_scheme='implicit'
#
```

::: {.cell-output .cell-output-stdout}
```
Directory for storing output created at /tmp/sureau_output_2025_02_12_1322
```
:::

::: {.cell-output .cell-output-display}
```
defaultdict(list,
            {'year_start': 1991,
             'year_end': 1992,
             'resolution_output': 'daily',
             'output_type': 'simple',
             'constant_climate': True,
             'pet_formulation': 'pt',
             'rn_formulation': 'linear',
             'time_step_for_evapo': 1,
             'time': array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
                    17, 18, 19, 20, 21, 22, 23]),
             'latitude': 90,
             'longitude': 180,
             'comp_options': defaultdict(list,
                         {'numerical_scheme': 'implicit',
                          'nsmalltimesteps': array([ 6, 10, 20, 60]),
                          'lsym': 1,
                          'ssym': 1,
                          'clapo': 1,
                          'ctapo': 1,
                          'eord': 1,
                          'lcav': 1,
                          'scav': 1}),
             'stomatal_reg_formulation': 'turgor',
             'defoliation': True,
             'threshold_mortality': 51,
             'transpiration_model': 'jarvis',
             'print_prog': True,
             'stop_simulation_dead_plant': True,
             'transpiration_granier_args': defaultdict(list,
                         {'a': -0.006, 'b': 0.134, 'c': 0}),
             'output_path': '/tmp/sureau_output_2025_02_12_1322'})
```
:::
:::


::: {#cell-6 .cell}
``` {.python .cell-code}
#create_modeling_options(latitude = 1,
#                        longitude = 1, 
#                        output_path = "/tmp",
#                        output_overwrite= True,
#                        comp_options_for_evapo='normal',
#                        output_type = "LFMC",
#                        resolution_output = "daily",
#                        year_start = 1000,
#                        year_end = 1001,
#                        time_step_for_evapo = 4)
```

::: {.cell-output .cell-output-stdout}
```
Directory for storing output created at /tmp/sureau_output_2025_02_12_3046
```
:::

::: {.cell-output .cell-output-display}
```
defaultdict(list,
            {'year_start': 1000,
             'year_end': 1001,
             'resolution_output': 'daily',
             'output_type': 'LFMC',
             'constant_climate': False,
             'pet_formulation': 'pt',
             'rn_formulation': 'linacre',
             'time_step_for_evapo': 4,
             'time': array([ 0,  4,  8, 12, 16, 20]),
             'latitude': 1,
             'longitude': 1,
             'comp_options': defaultdict(list,
                         {'numerical_scheme': 'implicit',
                          'nsmalltimesteps': array([ 24,  40,  80, 240]),
                          'lsym': 1,
                          'ssym': 1,
                          'clapo': 1,
                          'ctapo': 1,
                          'eord': 1,
                          'lcav': 1,
                          'scav': 1}),
             'stomatal_reg_formulation': 'sigmoid',
             'defoliation': False,
             'threshold_mortality': 90,
             'transpiration_model': 'jarvis',
             'print_prog': True,
             'stop_simulation_dead_plant': True,
             'transpiration_granier_args': defaultdict(list,
                         {'a': -0.006, 'b': 0.134, 'c': 0}),
             'output_path': '/tmp/sureau_output_2025_02_12_3046'})
```
:::
:::


