# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_plant_utils.ipynb.

# %% auto #0
__all__ = ['rs_comp', 'turgor_comp', 'compute_turgor_from_psi', 'osmo_comp', 'psi_total_symp_comp', 'stomatal_regulation_turgor',
           'plc_comp', 'plc_prime_comp', 'gs_curve', 'compute_gmin', 'compute_emin', 'compute_dfmc',
           'distribute_conductances', 'compute_g_crown', 'convert_flux_from_mmolm2s_to_mm',
           'convert_flux_from_mm_to_mmolm2s', 'calculate_ebound_mm_granier', 'calculate_ebound_granier',
           'compute_tleaf', 'create_empty_vegetation_parameter_file', 'read_vegetation_file', 'k_series_sum']

# %% ../nbs/04_plant_utils.ipynb #ed2bd8ce
import os
import warnings
import collections
import numpy as np
import pandas as pd

# import pandera as pa
from typing import Dict, List
from pydantic import ValidationError

# from pandera.typing import Series
from pathlib import Path, PosixPath
from .pysureau_utils import dict_to_csv
from .parameter_validators import VegetationParameterValidator

# %% ../nbs/04_plant_utils.ipynb #1d5f9054
def rs_comp(
    pi_ft: float,  # Osmotic potential at full turgor (MPa)
    e_symp: float,  # Modulus of elastoicoty of the Symplasm (MPa/%)
    psi: float,  # Unknown parameter definition
) -> float:
    "Compute Rs from pmin (resolution from Bartlet et al 2012 EcolLett and email Herve Cochard 19/06/2015)"
    return max(
        # Firts term
        (
            -1 * (psi + pi_ft - e_symp)
            - np.sqrt((psi + pi_ft - e_symp) ** 2 + 4 * (psi * e_symp))
        )
        / (2 * e_symp),
        # Second term
        1 - pi_ft / psi,
    )

# %% ../nbs/04_plant_utils.ipynb #51f9e941
def turgor_comp(
    pi_ft: float,  # Osmotic potential at full turgor (MPa)
    e_symp: float,  # Modulus of elastoicoty of the Symplasm (MPa/%)
    r_stemp: float,  # Unknown parameter definition
) -> float:
    "Turgor pressure"
    return -pi_ft - e_symp * r_stemp

# %% ../nbs/04_plant_utils.ipynb #da24a306
def compute_turgor_from_psi(
    pi_ft: float,  # Osmotic potential at full turgor (MPa)
    e_symp: float,  # Modulus of elastoicoty of the Symplasm (MPa/%)
    psi: List,  # List of Water potential of the organ (MPa)
) -> np.array:
    "Computes Turgor pressure from Pressure-Volume curves parameters and water potential"

    # Make sure psi is a list
    assert isinstance(psi, List), (
        f'psi must be a List with float values (i.e [1] or [1,2,..]) not a {type(psi)}'
    )

    # Compute symplasm relative water deficit (rwd) from each psi value

    # Generates an array of length psi
    rwd_1 = (
        -1 * (np.array(psi) + pi_ft - e_symp)
        - np.sqrt(
            (np.array(psi) + pi_ft - e_symp) ** 2 + 4 * (np.array(psi) * e_symp)
        )
    ) / (2 * e_symp)

    # Generates an array of length psi
    rwd_2 = 1 - pi_ft / np.array(psi)

    # Create empty array for storing values
    rs_array = np.zeros(0, dtype=float)

    for each_rwd_1, each_rwd_2 in zip(rwd_1, rwd_2):
        # Compare relative_water_deficit_1 and relative_water_deficit_2 and store
        # the largest one into array
        rs_array = np.append(rs_array, max(each_rwd_1, each_rwd_2))

    # Calculate turgor
    turgor_array = -pi_ft - e_symp * rs_array

    # Replace negative values inside the turgor array with 0's
    turgor_array[(turgor_array < 0)] = 0

    return turgor_array

# %% ../nbs/04_plant_utils.ipynb #526fd7b2
# Osmotic potential
def osmo_comp(
    pi_ft: float,  # Osmotic potential at full turgor (MPa)
    r_stemp: float,  # Unknown parameter definition
) -> float:
    "Compute osmotic potential"
    return pi_ft / (1 - r_stemp)

# %% ../nbs/04_plant_utils.ipynb #76525e8c
def psi_total_symp_comp(
    pi_ft: float,  # Osmotic potential at full turgor (MPa)
    e_symp: float,  # Modulus of elastoicoty of the Symplasm (MPa/%)
    r_stemp: float,  # Unknown parameter definition
) -> float:
    "Compute Total potential"
    turgor = turgor_comp(pi_ft=pi_ft, e_symp=e_symp, r_stemp=r_stemp)

    osmo = osmo_comp(pi_ft=pi_ft, r_stemp=r_stemp)

    return turgor + osmo

# %% ../nbs/04_plant_utils.ipynb #677140af
def stomatal_regulation_turgor(
    turgor_pressure: float,  # Turgor pressure
    max_turgor_pressure: float,  # Maximum turgor pressure,
    e_max: float,  # Unknown parameter definition
    e_cuti: float,  # Residual Transpiration
) -> np.array:
    "This function computes stomatal regulation if stomatal closure is limited (linearly) by turgor pressure"

    # Create np.array for storing values
    stomatal_reg_array = np.zeros(0, dtype=float)

    # Get the lowest value
    tr = min((e_max * turgor_pressure / max_turgor_pressure), e_max)

    # Append to array
    stomatal_reg_array = np.append(stomatal_reg_array, max(tr, 0))

    # Horrible line but I don't know how to improve it
    # Don't know the meaning of 0 + e_cuti
    horror_line = min(max(max(tr, 0) + e_cuti, 0 + e_cuti), e_max)

    stomatal_reg_array = np.append(stomatal_reg_array, horror_line)

    return stomatal_reg_array

# %% ../nbs/04_plant_utils.ipynb #5564f5ab
def plc_comp(
    psi: float,  # Unknown parameter definition
    slope: float,  # Unknown parameter definition
    p50: float,  # Unknown parameter definition
) -> float:
    "Compute Percentage loss of conductivity"

    return 100 / (1 + np.exp(slope / 25 * (psi - p50)))

# %% ../nbs/04_plant_utils.ipynb #3b537e90
def plc_prime_comp(
    plc: float,  # Computed using the `plc_comp` function
    slope: float,  # Unknown parameter definition
) -> float:
    "This function computes PLC Prime from PLC current value"

    return -slope / 25 * plc / 100 * (1 - plc / 100)

# %% ../nbs/04_plant_utils.ipynb #0f2ea7de
def gs_curve(
    x: float,  # Unknown parameter definition
    slope_gs: float,  # Unknown parameter definition
    p50_gs: float,  # Unknown parameter definition
    psi_start_closing: float,  # Unknown parameter definition
    psi_close: float,  # Unknown parameter definition
    pi_ft: float,  # Osmotic potential at full turgor (MPa)
    e_symp: float,  # Modulus of elastoicoty of the Symplasm (MPa/%)
    turgor_pressure_at_gs_max: float,  # Unknown parameter definition
    gs_max: float,  # Unknown parameter definition
    transpiration_model: str = ['jarvis', 'granier'],  # Transpiration model type
    stomatal_reg_formulation: str = [  # Type of regulation to be used for stomatal response to leaf symplasmic water potential.
        'sigmoid',
        'piecewise_linear',
        'turgor',
    ],
) -> float:
    "To obtain plots of the gs regulation curve"

    assert stomatal_reg_formulation in [
        'sigmoid',
        'piecewise_linear',
        'turgor',
    ], (
        f'{stomatal_reg_formulation} not a valid option, choose "sigmoid", "piecewise_linear" or "turgor" '
    )

    assert transpiration_model in [
        'jarvis',
        'granier',
    ], f'{transpiration_model} not a valid option, choose  "jarvis" or "granier"'

    if transpiration_model == 'granier':
        gs_max = 1

    if stomatal_reg_formulation == 'sigmoid':
        pl_gs = 1 / (1 + np.exp(slope_gs / 25 * (x - p50_gs)))
        regul_fact = 1 - pl_gs

    if stomatal_reg_formulation == 'piecewise_linear':
        regul_fact = (x - psi_close) / (psi_start_closing - psi_close)

        if regul_fact < 0:
            regul_fact = 0

        elif regul_fact > 1:
            regul_fact = 1

        else:
            print(
                "Original code don't take into account regul_fact between 0 and 1"
            )

    if stomatal_reg_formulation == 'turgor':
        # Only Rs1 is needed above TLP
        rs1 = (
            -1 * (x + pi_ft - e_symp)
            - np.sqrt((x + pi_ft - e_symp) ** 2 + 4 * (x * e_symp))
        ) / (2 * e_symp)

        # turgor loss point variable created but not used
        turgor_loss_point = (pi_ft * e_symp) / (pi_ft + e_symp)

        turgor = -pi_ft - e_symp * rs1
        regul_fact < -turgor / turgor_pressure_at_gs_max

        if regul_fact < 0:
            regul_fact = 0

        elif regul_fact > 1:
            regul_fact = 1

        else:
            print(
                "Original code don't take into account regul_fact between 0 and 1"
            )

    return regul_fact * gs_max

# %% ../nbs/04_plant_utils.ipynb #8214d9a0
def compute_gmin(
    leaf_temp: float,  # Temperature of the leaf (degC)
    gmin_20: float,  # leaf conductance at 20 degC
    t_phase: float,  # Temperature for phase transition of gmin
    q10_1: float,  # Q10 values for g_min= f(T) below T_phase
    q10_2: float,  # Q10 values for g_cuti = f(T) above T_phase
    gmin_temp_off=False,  # Unknown parameter definition
) -> float:
    "Calculate minimum conductance (gmin) following Cochard et al. (2019). Equantion 31 and 32 from SurEau-Ecos paper"

    print('original R code have a ambiguous gmin_temp_off specification')
    if gmin_temp_off is False:
        if leaf_temp <= t_phase:
            gmin = gmin_20 * q10_1 ** ((leaf_temp - 20) / 10)
            return gmin

        elif leaf_temp > t_phase:
            gmin = (
                gmin_20
                * q10_1 ** ((t_phase - 20) / 10)
                * q10_2 ** ((leaf_temp - t_phase) / 10)
            )
            return gmin

    else:
        print('gmin_temp_off = True. Returning gmin20 as gmin value')
        return gmin_20

# %% ../nbs/04_plant_utils.ipynb #63bb8acd
def compute_emin(
    gmin: float,  # Minimum conductance
    vpd: float,  # Vapor Pressure Deficit  (kPa)
    g_bl: float,  # Unknown parameter definition
    g_crown: float,  # Conductance of the tree crown. Calculated using `compute_g_crown` function
    air_pressure: float = 101.3,  # Surface air pressure (kPa)
) -> float:
    "Calculate minimum transpiration (emin)"

    gmin_tot = 1 / (1 / gmin + 1 / g_bl + 1 / g_crown)
    return gmin_tot * (vpd / air_pressure)

# %% ../nbs/04_plant_utils.ipynb #f83145dd
def compute_dfmc(
    vpd: float,  # Vapor pressure deficit (kPA)
    fm0=5.43,  # Minimum fuel moisture content (% dry weight)
    fm1=52.91,  # Maximum fuel moisture content (% dry weight)
    m=0.64,  # Rate of decay
) -> float:  # Fuel moisture content (% dry weight)
    "Compute dead fuel moisture content from VPD following De Dios et al. (2015)"
    return fm0 + fm1 * np.exp(-m * vpd)

# %% ../nbs/04_plant_utils.ipynb #f1e977a4
def distribute_conductances(
    k_plant_init: float,  # Conductance of the plant from root to leaf
    ri: float,  # Root distribution within the soil layers.
    frac_leaf_sym: float = 0.4,  # Proportion of k_plant_init assigned to the leaf (apoplasm to symplasm pathway)
) -> Dict:
    "Calcultate hydraulic conductances in the different portions of the plant (trunk, leaf and root) according to predetermined rules"

    frac_rt = (2 / 3) * (1 - frac_leaf_sym)

    fract_tl = (1 / 3) * (1 - frac_leaf_sym)

    k_rsapo_init = 1 / (frac_rt / k_plant_init) * ri

    k_slapo_init = 1 / (fract_tl / k_plant_init)

    k_lsym_init = 1 / (frac_leaf_sym / k_plant_init)

    # TODO: AJOUTE UN CALCUL DES CONDUCTANCE ICI POUR CHECK DU CALCUL? e.g.:
    # k_PlantInit <-  1/ (1 /sum(k_RSApoInit) + 1/k_SLApoInit + 1/k_LSymInit)

    dictionary = {
        'k_slapo_init': k_slapo_init,
        'k_lsym_init': k_lsym_init,
        'k_rsapo_init': k_rsapo_init,
        'k_plant_init': k_plant_init,
    }

    return collections.defaultdict(list, dictionary)

# %% ../nbs/04_plant_utils.ipynb #b4e5d4dc
def compute_g_crown(
    g_crown0: float,  # Reference tree crown conductance
    wind_speed: float,  # Unknown parameter definition
) -> float:
    "Calcultate g_crown"

    # to avoid very high conductance values
    wind_speed = max(0.1, wind_speed)

    return g_crown0 * wind_speed**0.6

# %% ../nbs/04_plant_utils.ipynb #f6761fcb
def convert_flux_from_mmolm2s_to_mm(
    x: float,  # The amount of water in mm (L.m-2soil)
    time_step: float,  # Time step (in hours)
    lai: float,  # Leaf area index of the stand (m2leaf.m-2soil)
) -> float:
    "Convert an instantaneous flux in mmol.m-2Leaf.s-1 to a amount in mm (L.m2soil) over a defined time period"
    return x * (lai * time_step * 3600 * 18) / 10**6

# %% ../nbs/04_plant_utils.ipynb #8b99c704
def convert_flux_from_mm_to_mmolm2s(
    x: float,  # The amount of water in mm (L.m-2soil)
    time_step: float,  # Time step (in hours)
    lai: float,  # Leaf area index of the stand (m2leaf.m-2soil)
) -> float:
    "Convert flux in L.m-2soil to an instantaneous flux in mmol/m-2leaf.s-1 over a defined time period"
    if lai > 0:
        return (10**6 * x) / (lai * time_step * 3600 * 18)

    else:
        return 0

# %% ../nbs/04_plant_utils.ipynb #01d24973
def calculate_ebound_mm_granier(
    etp: float,  # Unknown parameter definition
    lai: float,  # Leaf area index of the stand (m2leaf.m-2soil)
    a: float = -0.006,  # Unknown parameter definition
    b: float = 0.134,  # Unknown parameter definition
    c: float = 0,  # Unknown parameter definition
) -> float:
    "No description found in R source code"

    # Get the maximum value
    # Example of np.maximum: np.maximum(5, [1,2,6]) == array([5, 5, 6])
    return np.maximum(0, etp * (a * lai**2 + b * lai + c))

# %% ../nbs/04_plant_utils.ipynb #e8a8dd7f
def calculate_ebound_granier(
    pet: float,  # Unknown parameter definition
    lai: float,  # Leaf area index of the stand (m2leaf.m-2soil)
    time_step: float,  # Time step (in hours)
) -> float:
    "No description found in R source code"

    # Assert parameters ---------------------------------------------------------
    # pet
    assert (
        isinstance(pet, float)
        | isinstance(pet, int)
        | isinstance(pet, np.ndarray)
    ), 'pet missing. Parameter must be a float or integer value'

    # lai
    assert (
        isinstance(lai, float)
        | isinstance(lai, int)
        | isinstance(lai, np.ndarray)
    ), 'lai missing. Parameter must be a float or integer value'

    # time_step
    assert isinstance(time_step, int) | isinstance(time_step, np.ndarray), (
        'nhours missing. Parameter must be a float or integer value'
    )

    ebound_mm = calculate_ebound_mm_granier(etp=pet, lai=lai)

    return convert_flux_from_mm_to_mmolm2s(
        x=ebound_mm, time_step=time_step, lai=lai
    )

# %% ../nbs/04_plant_utils.ipynb #bebca7be
def compute_tleaf(
    t_air: float,  # Air temperature (degC)
    par: float,  # Unknown parameter definition
    potential_par: float,  # Unknown parameter definition. Calculated using `potential_par` function?
    wind_speed: float,  # Unknown parameter definition (m/s)
    relative_humidity: int,  # Air relative_humidity(%)
    gs: float,  # Stomatal conductance
    g_cuti: float,  # leaf conductance
    e_inst: float,  # Unknown parameter definition
    psi_leaf: float,  # Unknown parameter definition
    leaf_size: float = 50,  # Characteristic dimension from vegetation params in mm i.e. 1 (pine needle) to 3000 (banana leaf)
    leaf_angle: int = 45,  # Leaf angle (depuis le plan horizontal : 0-90 deg)
    turn_off_eb: bool = False,  # Unknown parameter definition. Tleaf Energy balance?
    transpiration_model: str = ['jarvis', 'granier'],  # Transpiration model type
) -> Dict:  # Dictionary with parameters
    "Compute leaf temperature and Vapour Pressure deficit"

    # Assert parameters ---------------------------------------------------------

    # t_air
    assert -40 <= t_air <= 70, (
        'Unrealistic air temperature, value must be a value between -40 and 70'
    )

    # par
    assert 0 < par <= 2500, (
        'Unrealistic par, value must be a value between 0 and 2500'
    )

    # potential_par
    assert 0 < potential_par <= 2500, (
        'Unrealistic potential_par, value must be a value between 0 and 2500'
    )

    # gs
    assert 0 < gs <= 25, 'Unrealistic gs, value must be a value between 0 and 25'

    # g_cuti
    assert 0 < g_cuti <= 200, (
        'Unrealistic g_cuti, value must be a value between 0 and 200'
    )

    # e_inst
    assert 0 < e_inst, 'Unrealistic e_inst, value must be a value greater than 0'

    # psi_leaf
    assert 0 > psi_leaf, 'Water potential values must be negative'

    # Leaf size
    assert isinstance(leaf_size, float) | isinstance(leaf_size, int), (
        'turn_off_eb must be boolean (True or False)'
    )

    # Relative humidity
    assert 0 <= relative_humidity <= 100, (
        'relative_humidity must be a value between 0 and 100'
    )

    assert isinstance(turn_off_eb, bool), (
        'turn_off_eb must be boolean (True or False)'
    )

    assert 0 <= leaf_angle <= 90, 'leaf_angle must be a value between 0 and 90'

    assert transpiration_model in [
        'jarvis',
        'granier',
    ], f'{transpiration_model} not a valid option, choose  "jarvis" or "granier"'

    # Constants -----------------------------------------------------------------

    # Force minimum wind speed to avoid excessive heating
    wind_speed = np.maximum(wind_speed, 0.1)

    # Calculate short-wave radiation (W/m2) # from µmol/m2/s to Watts/m2
    short_wave_radiation = par * 0.5495

    # Absorptance to short_wave_radiation (%)
    abs_short_wave_radiation = 0.5

    # # Unknown meaning of g_flat
    g_flat = 0.00662

    # Coefficient in rbl equation m
    g_cyl = 0.00403

    # # Unknown meaning of j_flat
    j_flat = 0.5

    # Coefficient in rbl equation  none
    j_cyl = 0.6

    # Emissivity none
    emiss_leaf = 0.97

    # Stefan-Boltzman constant   W m-2 K-4
    stefan_boltzman_const = 5.6704e-8

    # Density of dry air kg/m3
    dry_air_density = 1.292

    # Heat capacity of dry air  J kg-1 K-1
    heat_capacity_dry_air = 1010

    # Psychrometric constant kPa K-1
    psychro_constant = 0.066

    # Coefficient in esat equation kPa
    e_sat_coeff_a = 0.61121

    # Coefficient in esat equation none
    e_sat_coeff_b = 17.502

    # Coefficient in esat equation °C
    e_sat_coeff_z = 240.97

    # Original comment found in the source code
    # VARAIBLE CALCULEES
    # rst  #  stomatal resistance s m-1 (not needed)
    # esat #  saturation vapor pressure    kPa
    # ea   # water vapor pressure of the air    kPa
    # em_air # air emissivity
    # s   # slope of esat/T curve    kPa oC-1
    # SWRabs #   absorbed short-wave radiation    W m-2
    # LWRin  # incoming long-wave radiation    W m-2
    # LWRouti # isothermal outgoing long-wave radiation    W m-2
    # Rni # isothermal net radiation    W m-2
    # rr # radiative resistance    s m-1
    # rblr # boundary-layer + radiative resistance    s m-1
    # ym #  modified psychrometric constant    kPa K-1
    # rbl # leaf boundary-layer resistance    s m-1
    # Delta_T  # leaf-to-air temperature difference    degC
    # Tleaf, Tleaf_NonLinear # leaf temperature    degC

    # Create cloud_cover var
    if potential_par > 0:
        cloud_cover = par / potential_par

    else:
        cloud_cover = 0

    if cloud_cover > 1:
        cloud_cover = 1

    # ; #kPa  Unknown meaning of e_sat
    e_sat = e_sat_coeff_a * np.exp(
        e_sat_coeff_b * t_air / (t_air + e_sat_coeff_z)
    )

    # Unknown meaning of ea
    ea = e_sat * (relative_humidity / 100)

    # Unknown meaning of s
    s = e_sat * e_sat_coeff_b * e_sat_coeff_z / ((t_air + e_sat_coeff_z) ** 2)

    #  Unknown meaning of em_air
    em_air = (1 - 0.84 * cloud_cover) * 1.31 * (
        (10 * ea / (t_air + 273.15)) ** 0.14285714
    ) + 0.84 * cloud_cover

    # Update VPD with esat and ea (why?)
    vpd_x = e_sat - ea

    # Bilan radiatif ------------------------------------------------------------

    # Radiation absorbed by leaves
    swr_abs = (
        abs_short_wave_radiation
        * np.cos(leaf_angle * 3.1416 / 180)
        * short_wave_radiation
    )

    # Incoming long-wave radiation (W m-2) for clear and cloudy sky
    lwr_in = em_air * stefan_boltzman_const * (t_air + 273.15) ** 4

    # Outcoming long-wave radiation (W m-2) for clear and cloudy sky
    lwr_outi = emiss_leaf * stefan_boltzman_const * (t_air + 273.15) ** 4

    # isothermal net radiation
    rni = swr_abs + lwr_in - lwr_outi

    # Radiative resistance
    rad_res = (
        dry_air_density
        * heat_capacity_dry_air
        / (4 * emiss_leaf * stefan_boltzman_const * (t_air + 273.15) ** 3)
    )

    # Boundary layer resistance
    if leaf_size > 3:
        # Unknown meaning of rbl
        rbl = 1 / (
            1.5
            * g_flat
            * ((wind_speed**j_flat) / ((leaf_size / 1000) ** (1 - j_flat)))
        )

    else:
        # a needle, formula for a cylinder. I am assuming that this comment
        # belongs to the following line

        # Unknown meaning of rbl
        rbl = 1 / (
            1.5
            * g_cyl
            * ((wind_speed**j_cyl) / ((leaf_size / 1000) ** (1 - j_cyl)))
        )  # A flat leaf if > 3mm

    # leaf boundary layer conductance in mmol/s/m2
    g_bl = 1 / rbl * 1000 * 40

    # Unknown meaning of rblr
    rblr = 1 / (1 / rbl + 1 / rad_res)

    # Include the gs term into the energy balance
    if transpiration_model == 'jarvis':
        if (gs + g_cuti) > 0:
            # Unknown meaning of rst
            rst = 1 / (gs + g_cuti) * 1000 * 40

        else:
            # Unknown meaning of rst
            rst = 9999.99

    if transpiration_model == 'granier':
        # Unknown meaning of g
        g = e_inst / vpd_x * 101.3

        if g > 0:
            # Unknown meaning of rbl
            rst = 1 / (g) * 1000 * 40

        else:
            # Unknown meaning of rbl
            rst = 9999.99

    # Unknown meaning of ym
    ym = psychro_constant * (rst / rblr)

    # Compute Tleaf with linear approximation -----------------------------------
    delta_t = (
        ym * rni * rblr / (dry_air_density * heat_capacity_dry_air) - vpd_x
    ) / (s + ym)

    t_leaf = t_air + delta_t

    # Create a copy of t_leaf. I don't understand why this is done
    # t_leaf_copy =  t_leaf

    # Saturation vapour water pressure at Tair in Pa from Buck's equation
    e_sat_air = 611.21 * np.exp(
        (18.678 - t_air / 234.5) * t_air / (257.14 + t_air)
    )

    # Vapour water pressure at Tair and RHair
    e_air = e_sat_air * relative_humidity / 100

    # Calculate VPD air
    vpd_air = (e_sat_air - e_air) / 1000

    # Saturation vapour water pressure at Tair in Pa from Buck's equation
    e_sat_leaf = 611.21 * np.exp(
        (18.678 - t_leaf / 234.5) * t_leaf / (257.14 + t_leaf)
    )

    # Unknown meaning of e
    e = e_sat_leaf * np.exp(psi_leaf * 2.16947115 / (t_leaf + 273.15))

    # effect of leaf water potential on e
    # vpd between leaf and air in kPa
    vpd_leaf = np.maximum(0, (e - e_air) / 1000)

    if turn_off_eb is False:
        vecres = collections.defaultdict(
            list,
            {
                't_leaf': t_leaf,
                'g_bl': g_bl,
                'vpd_leaf': vpd_leaf,
                'vpd_air': vpd_air,
                'delta_t': delta_t,
            },
        )

    # If turn off energy balance Tleaf = Tair
    if turn_off_eb is True:
        vecres = np.array([t_air, g_bl, vpd_leaf, vpd_air])

        vecres = collections.defaultdict(
            list,
            {
                't_air': t_air,
                'g_bl': g_bl,
                'vpd_leaf': vpd_leaf,
                'vpd_air': vpd_air,
            },
        )

    return vecres

# %% ../nbs/04_plant_utils.ipynb #10a93287
def create_empty_vegetation_parameter_file(
    path: Path,  # Path to the folder where the parameter files will be saved. If set to None then the files will be saved at the current working directory
) -> Dict:  # Return two dictionary files for user input
    "Function for creating the CSV templates necessary for the vegetation parameters"

    # Assert parameters ---------------------------------------------------------
    assert isinstance(path, str) | isinstance(path, PosixPath), (
        f'Input path must be a str, not a {type(path).__name__}'
    )

    # Convert string to Path if provided ----------------------------------------
    path = Path(path)
    if os.path.exists(path):
        # Soil parameters for van Genuchten pedo transfer function
        vegetation_params = {
            'apo_frac_leaf': 'NA',
            'apo_frac_stem': 'NA',
            'beta_root_profile': 'NA',
            'c_lapo_init': 'NA',
            'c_sapo_init': 'NA',
            'canopy_storage_param': 'NA',
            'day_start': 'NA',
            'day_end': 'NA',
            'epsilon_sym_leaf': 'NA',
            'epsilon_sym_stem': 'NA',
            'f_crit': 'NA',
            'foliage': 'NA',
            'f_root_to_leaf': 'NA',
            'f_trb_to_leaf': 'NA',
            'g_crown0': 'NA',
            'group': 'NA',
            'gmin_s': 'NA',
            'gmin20': 'NA',
            'gs_max': 'NA',
            'gs_night': 'NA',
            'jarvis_par': 'NA',
            'k': 'NA',
            'k_plant_init': 'NA',
            'k_ssym_init': 'NA',
            'lai_max': 'NA',
            'leaf_angle': 'NA',
            'leaf_size': 'NA',
            'life_form': 'NA',
            'lmdc': 'NA',
            'lma': 'NA',
            'nb_day_lai': 'NA',
            'p12_gs': 'NA',
            'p50_vc_leaf': 'NA',
            'p50_vc_stem': 'NA',
            'p88_gs': 'NA',
            'pi_full_turgor_leaf': 'NA',
            'pi_full_turgor_stem': 'NA',
            'psi_close': 'NA',
            'psi_start_closing': 'NA',
            'pt_coeff': 'NA',
            'q10_1_gmin': 'NA',
            'q10_2_gmin': 'NA',
            'root_radius': 'NA',
            'slope_vc_leaf': 'NA',
            'slope_vc_stem': 'NA',
            'species': 'NA',
            'sym_frac_stem': 'NA',
            'sym_frac_leaf': 'NA',
            't_base': 'NA',
            't_gs_optim': 'NA',
            't_gs_sens': 'NA',
            't_phase_gmin': 'NA',
            'turgor_pressure_at_gs_max': 'NA',
            'vol_stem': 'NA',
        }
        # Write to CSV files
        dict_to_csv(
            dictionary=vegetation_params,
            path=path,
            filename='vegetation_parameters.csv',
        )

    else:
        raise ValueError('Failed creating empty vegetation parameter file')

# %% ../nbs/04_plant_utils.ipynb #8a02a9db
def read_vegetation_file(
    file_path: Path,  # Path to the sureau_parameter_files folder containing the csv files with parameter values i.e path/to/sureau_parameter_files/file_name.csv
    sep: str = ',',  # CSV file separator can be ',' or ';'
) -> Dict:
    "Function for reading a data frame containing information about vegetation characteristics"

    # Assert parameters ---------------------------------------------------------

    # Make sure that modeling_options file exist
    assert os.path.exists(file_path), (
        f'Path to vegetation parameter file not found. Check spelling or presence {file_path}.'
    )

    # Read CSV data frames -----------------------------------------------------

    # Read vegetation parameters file
    vegetation_parameters_data = pd.read_csv(file_path, header=0, sep=sep)

    # Validate parameter files ---------------------------------------------------

    # Validate the column names of vegetation parameters file are parameter_name, parameter_value
    # To correctly transform the the CSV file as dict later
    if vegetation_parameters_data.columns.tolist() != [
        'parameter_name',
        'parameter_value',
    ]:
        raise ValueError(
            'Column names in vegetation parameters file must be called parameter_name and parameter_value'
        )

    # Transform dataframe into dictionary
    vegetation_parameters_dict = vegetation_parameters_data.set_index(
        'parameter_name'
    ).to_dict()['parameter_value']

    # Loop over dictionary to transform the data types.
    # This step is done beacuse the csv file can contain str sand float values

    parameters_of_class_str = ['foliage', 'group', 'life_form', 'species']

    # Loop over all keys.
    for each_key in vegetation_parameters_dict.keys():
        if each_key in parameters_of_class_str:
            # If value is in parameters_of_class_str then transform to str
            vegetation_parameters_dict[each_key] = str(
                vegetation_parameters_dict[each_key]
            )

        else:
            # Transform parameters values to float
            vegetation_parameters_dict[each_key] = float(
                vegetation_parameters_dict[each_key]
            )

    # Validate Vegetation parameter file pydanthic schema
    try:
        VegetationParameterValidator.model_validate(vegetation_parameters_dict)

    except ValidationError as error:
        raise (error)

    return vegetation_parameters_dict

# %% ../nbs/04_plant_utils.ipynb #23d83da3
def k_series_sum(k1: float, k2: float) -> float:
    "Function to sum 2 conductances in series"

    # Assert parameters ---------------------------------------------------------
    assert isinstance(k1, float) or isinstance(k1, int), (
        'k1 must be a numeric value'
    )

    assert isinstance(k1, float) or isinstance(k2, int), (
        'k2 must be a numeric value'
    )

    # Sum conductances ----------------------------------------------------------
    return 1 / (1 / k1 + 1 / k2)
